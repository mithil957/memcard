###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Chunk","DemoExample","DemoExampleV2","Flashcard","Segment","SegmentRaw","StudyInput","TopicSummaryWithSegments",]
        ), enums=set(
          ["FlashcardType","SegmentType",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def Chunk(self) -> "ChunkAst":
        return ChunkAst(self)

    @property
    def DemoExample(self) -> "DemoExampleAst":
        return DemoExampleAst(self)

    @property
    def DemoExampleV2(self) -> "DemoExampleV2Ast":
        return DemoExampleV2Ast(self)

    @property
    def Flashcard(self) -> "FlashcardAst":
        return FlashcardAst(self)

    @property
    def Segment(self) -> "SegmentAst":
        return SegmentAst(self)

    @property
    def SegmentRaw(self) -> "SegmentRawAst":
        return SegmentRawAst(self)

    @property
    def StudyInput(self) -> "StudyInputAst":
        return StudyInputAst(self)

    @property
    def TopicSummaryWithSegments(self) -> "TopicSummaryWithSegmentsAst":
        return TopicSummaryWithSegmentsAst(self)





class ChunkAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Chunk")
        self._properties: typing.Set[str] = set([ "chunk_text", ])
        self._props = ChunkProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChunkProperties":
        return self._props


class ChunkViewer(ChunkAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChunkProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def chunk_text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("chunk_text"))

    

class DemoExampleAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DemoExample")
        self._properties: typing.Set[str] = set([ "segment_type",  "segment_text",  "chunks", ])
        self._props = DemoExampleProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DemoExampleProperties":
        return self._props


class DemoExampleViewer(DemoExampleAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DemoExampleProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def segment_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_type"))

    @property
    def segment_text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_text"))

    @property
    def chunks(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("chunks"))

    

class DemoExampleV2Ast:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DemoExampleV2")
        self._properties: typing.Set[str] = set([ "segment_type",  "segment_text",  "chunks", ])
        self._props = DemoExampleV2Properties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DemoExampleV2Properties":
        return self._props


class DemoExampleV2Viewer(DemoExampleV2Ast):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DemoExampleV2Properties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def segment_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_type"))

    @property
    def segment_text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_text"))

    @property
    def chunks(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("chunks"))

    

class FlashcardAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Flashcard")
        self._properties: typing.Set[str] = set([ "type",  "front",  "back", ])
        self._props = FlashcardProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FlashcardProperties":
        return self._props


class FlashcardViewer(FlashcardAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FlashcardProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def front(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("front"))

    @property
    def back(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("back"))

    

class SegmentAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Segment")
        self._properties: typing.Set[str] = set([ "segment_number",  "segment_type",  "segment_text", ])
        self._props = SegmentProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SegmentProperties":
        return self._props


class SegmentViewer(SegmentAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SegmentProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def segment_number(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_number"))

    @property
    def segment_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_type"))

    @property
    def segment_text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_text"))

    

class SegmentRawAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SegmentRaw")
        self._properties: typing.Set[str] = set([ "segment_type",  "segment_text", ])
        self._props = SegmentRawProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SegmentRawProperties":
        return self._props


class SegmentRawViewer(SegmentRawAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SegmentRawProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def segment_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_type"))

    @property
    def segment_text(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segment_text"))

    

class StudyInputAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("StudyInput")
        self._properties: typing.Set[str] = set([ "topics",  "highlights", ])
        self._props = StudyInputProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "StudyInputProperties":
        return self._props


class StudyInputViewer(StudyInputAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class StudyInputProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def topics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("topics"))

    @property
    def highlights(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("highlights"))

    

class TopicSummaryWithSegmentsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("TopicSummaryWithSegments")
        self._properties: typing.Set[str] = set([ "topicSummary",  "segments", ])
        self._props = TopicSummaryWithSegmentsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TopicSummaryWithSegmentsProperties":
        return self._props


class TopicSummaryWithSegmentsViewer(TopicSummaryWithSegmentsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TopicSummaryWithSegmentsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def topicSummary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("topicSummary"))

    @property
    def segments(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("segments"))

    



class FlashcardTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("FlashcardType")
        self._values: typing.Set[str] = set([ "BASIC_FACT",  "EXPLANATION",  "APPLICATION",  "CONTEXT", ])
        self._vals = FlashcardTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "FlashcardTypeValues":
        return self._vals


class FlashcardTypeViewer(FlashcardTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class FlashcardTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def BASIC_FACT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("BASIC_FACT"))
    

    @property
    def EXPLANATION(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("EXPLANATION"))
    

    @property
    def APPLICATION(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("APPLICATION"))
    

    @property
    def CONTEXT(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CONTEXT"))
    

    

class SegmentTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SegmentType")
        self._values: typing.Set[str] = set([ "TEXT_BLOCK",  "HEADING",  "CODE_BLOCK",  "IMAGE_DESCRIPTION",  "FIGURE_CAPTION",  "FOOTER",  "LIST_ITEM",  "TABLE",  "OTHER", ])
        self._vals = SegmentTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SegmentTypeValues":
        return self._vals


class SegmentTypeViewer(SegmentTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class SegmentTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def TEXT_BLOCK(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("TEXT_BLOCK"))
    

    @property
    def HEADING(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("HEADING"))
    

    @property
    def CODE_BLOCK(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("CODE_BLOCK"))
    

    @property
    def IMAGE_DESCRIPTION(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("IMAGE_DESCRIPTION"))
    

    @property
    def FIGURE_CAPTION(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("FIGURE_CAPTION"))
    

    @property
    def FOOTER(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("FOOTER"))
    

    @property
    def LIST_ITEM(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("LIST_ITEM"))
    

    @property
    def TABLE(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("TABLE"))
    

    @property
    def OTHER(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("OTHER"))
    

    


__all__ = ["TypeBuilder"]